<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Algoritmica</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/league.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>1.2 Brute-force</section>
				<section>
					Inquadrare e illustrare il concetto <em>visita Brute-Force</em> nell'ambito della ricerca di risposte a problemi algoritmicamente intrattabili.
				</section>
				<section id="fragments">
					PL, PLI e le euristiche greedy non forniscono soluzioni efficienti per problemi reali come quello rappresentato da Valutazioni.
					<p class="fragment">
						Per trovare la risposta in modo esaustivo, si può formalizzare algoritmicamente la ricerca vagliando ogni possibile soluzione al problema.
					</p>
				</section>
				<section>
					Questo approccio viene comunemente definito
					<h3>Brute-Force</h3>
				</section>
				<section>
					La riformulazione algoritmica del problema Valutazioni si riduce alla generazione di tutte le permutazioni delle domande.
					<br>
					Questo approccio permette di affrontare un'intera classe di problemi in modo generico.
				</section>
				<section>
					L'algoritmo fissa una parte dell'array considerara già permutata (indici da 0 a $j$).
					<br>
					Ad ogni passo effettua l'inversione tra l'elemento a indice $j$ e l'elemento a indice $i$ (compreso tra $j+1$ e $len(array)$), generando una nuova permutazione.
				</section>
				<section data-markdown>
					<textarea data-template>
						```
						permutazioni(arr, j):
							if j == len(arr):
								print(arr)
								return
							for idx in range(j, len(arr)):
								arr.swap(idx, j)
								permutazioni(arr, j+1)
								arr.swap(idx, j)
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						Bandi, ovvero disposizioni:
						```algo
						disposizioni(arr, j, k):
							if j == k:
								print(arr(0..k))
								return
							for idx in range(j, len(arr)):
								arr.swap(idx, j)
								disposizioni(nums, j+1, k)
								arr.swap(idx, j)
						```
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						Rischio, ovvero disposizioni con ripetizioni:
						```
						disposizioni_ripetizioni(arr, sol, j, k):
							if j == k:
								print(arr(0..k))
								return
							for i in range(0, len(arr)):
								sol[j] = arr[i]
								arr.swap(i, j)
								disposizioni_ripetizioni(arr, sol, j+1, k)
								arr.swap(i, j)
						```
					</textarea>
				</section>
				<section>
					Le tecniche esposte permettono una ricerca esaustiva per molti problemi computazionalmente complessi.
					<br>
					Sono però trattabili per istanze significative?
				</section>
				<section>
					Il problema Valutazioni richiede la generazioni delle permutazioni di 50 elementi
					<br>
					$50! = 3 \times 10^{64}$
					<br>
					<br>
					Per dare un'idea di quanto sia un numero intrattabile:
					<ul>
						<li>Il numero di atomi dell'universo è circa $10^{80}$</li>
						<li>Se generassimo una permutazione all'attosecondo ci vorrebbero $3\times 10^{34}$ millenni per terminare.</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script src="../plugin/init.js"></script>
	</body>
</html>
