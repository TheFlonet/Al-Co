<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Algoritmica</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/league.css">
		
		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>1.7 KP e Branch&Bound</section>
				<section>Illustrare origine e funzionamento della tecnica algoritmica Branch&Bound relativa al problema dello zaino</section>
				<section>
					Gli algoritmi greedy sono in grado di fornire soluzioni più o meno ragionevoli per il problema dello zaino.
					<br>
					Se però si vuole una risposta al problema è necessario un approccio come quello del Branch&Bound, che è considerato ottimale per KP.
				</section>
				<section>
					La funzione costo è definita come: 
					$$\hat{c}(x[0\dots j)) = f(h(x[0\dots j))) + \hat{g}(x[0\dots j))$$
					Dove:
					<ul>
						<li>$x[0\dots j)$ indica l'E-node in cui tutti gli elementi con indice $< j$ hanno una valore assegnato</li>
						<li>$f(h(x[0\dots j)))$ è il profitto fino a quel punto</li>
						<li>$\hat{g}(x[0\dots j))$ è la previsione ottimistica del potenziale profitto rimanente</li>
					</ul>
				</section>
				<section>
					Durante l'esplorazione dell'albero è possibile calcolare due semplici stime di upper e lower bound:
					<ul>
						<li>L'algoritmo greedy è una stima del lower-bound</li>
						<li>L'algoritmo LKP è una stima dell'upper-bound</li>
					</ul>
				</section>
				<section>
					<h3>Invariante - caso base</h3>
					<p>
						Viene generata una prima soluzione partendo dalla radice $x[0\dots0)$ tramite l'algoritmo greedy
					</p>
				</section>
				<section>
					<h3>Invariante - passo induttivo</h3>
					<p>
						Avendo
						<ul>
							<li>$x[0\dots j)$ è l'E-node</li>
							<li>La soluzione migliore calcolata si trova in $x[0\dots r)$, e assicura il profitto $z^*(x[0\dots r))$</li>
						</ul>
						Si possono verificare tre casi:
					</p>
				</section>
				<section>
					<ol>
						<li>Rifiuto del nodo: posso potare l'intero sotto albero se
							<ul>
								<li>il nuovo nodo porta ad eccedere la capacità</li>
								<li>il nuovo upper-bound è minore del lower-bound ottimo</li>
							</ul>
						</li>
						<li>Aggiornamento: se il nuovo nodo migliora la stima del miglior profitto</li>
						<li>Espansione: se il sottoalbero è in grado di produrre soluzioni migliorative</li>
					</ol>
				</section>
				<section>Codice Python</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script src="../plugin/init.js"></script>
	</body>
</html>
